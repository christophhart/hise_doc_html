<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<base href="https://docs.hise.dev/"/>
	<title>HISE | ScriptNode | SNEX</title>
	<meta name="description" content="An overview over the Expression Language of Scriptnode">
	<link rel="stylesheet" type="text/css" href="/template/css/prism.css">
	<link rel="stylesheet" type="text/css" media="screen" href="/template/css/autoComplete.css">
	<link href="https://fonts.googleapis.com/css?family=Heebo" rel="stylesheet">
	<link rel="stylesheet" type="text/css" media="screen" href="/template/css/style.css">
	<script src="/template/scripts/toc.json"></script>
	<script language="javascript" src="/template/scripts/generate.js"></script>
</head>
<body>
	<header>
		<a id="nav-button">
		</a>
		<logo>
			
			<a href="/">
				<div class="heading">HISE Docs</div>
			</a>
		</logo>
		<div class="search">
			<input id="autoComplete" tabindex="1">
		</div>
	</header>

	<div class="container">
		<nav class="toc">
			<script>
				for (rootIndex in rootDb.Children) {
					document.write(createTocElement(rootDb.Children[rootIndex]));
				}
			</script>

		</nav>

		<div class="content"><h1 id="snex"><b>SNEX</b>
</h1>
<p>The Scriptnode Expression Language (<b>SNEX</b>
) is a simplified subset of the C language family and is used throughout scriptnode for customization behaviour.</p>
<ul><li><b>fast</b>
. The assembly code generated by the compiler should (more or less) match the performance of C++ compiled code. </li>
<li><b>easy to use</b>
. The syntax can be adapted within minutes for people who know C++ and / or Javascript.</li>
<li><b>safe</b>
 - it's impossible to crash the application. Every call that could lead to a access violation is wrapped into a safe check</li>
</ul>
<p>It's intended use is fast execution of expressions for signal processing algorithms. Unlike the HiseScript language, which is interpreted, the scriptnode expressions are JIT compiled and run in almost native speed (several orders of magnitude above HiseScript performance). When the scriptnode graph is exported as Cpp code, the expressions will be then compiled by the standard compiler (which is why it needs to be a strict subset of C / C++).</p>
<p>The JIT compiler uses the awesome <code>asmjit</code>
 library to emit the assembly instructions. Currently supported are macOS / Windows / Linux (32bit / 64bit). iOS support is not possible due to the security restriction that prevents allocation of executable memory.</p>
<p>There are two places where it can be used: in the <code>core.jit</code>
 node, which allows creating fully customizable nodes and at the connection between parameters (or modulation sources) via the <code>Expression</code>
 property which can be used to convert the value send to the connection target.</p>
<h2 id="getting-started"><b>Getting started</b>
</h2>
<p>The easiest way to get to know the language is to use the SNEX Playground which offers you a JIT compiler, a code editor with a predefined snippet and shows the assembly output that is fed directly to the CPU. It also uses the same callbacks as the <code>core.jit</code>
 node and offers various test signals that you can use to check your algorithm.</p>
<h2 id="language-reference"><b>Language Reference</b>
</h2>
<p>This is the complete language reference. Features that deviate from C / Cpp are <b>emphasized</b>
</p>
<p>The <b>SNEX</b>
 syntax uses brackets for blocks and semicolons for statements. Comment lines start with <code>//</code>
, multiline comments with <code>/** Comment */)</code>
</p>
<pre><code class="language-clike line-numbers">/** This is a 
    multiline comment
*/
{
    x; // a statement
}</code></pre>
<p>You can define variables in any scope (function scope or global scope), however <b>there are no anonymous scopes</b>
.</p>
<h2 id="language-structure"><b>Language structure</b>
</h2>
<p>A valid SNEX code consists of definitions of variables and functions:</p>
<pre><code class="language-clike line-numbers">// some variables
type a = something;
type b = somethingElse;
...

// function definitions
type functionName()
{
    //... function body
}</code></pre>
<p><b>There is no concept of classes or any other object oriented design principle.</b>
 The rationale behind this is that a SNEX compiled object is already like a class, and the scope of a single SNEX code does not exceed the complexity of a single C++ class.</p>
<h2 id="variables"><b>Variables</b>
</h2>
<p>Variable names must be a valid identifier, and <b>definitions must initialise the value</b>
:</p>
<pre><code class="language-clike line-numbers">type variableName = initialValue;</code></pre>
<p>You can also define constant values by prepending <code>const</code>
 to the definition:</p>
<pre><code class="language-clike line-numbers">const type value = initialValue;</code></pre>
<p>Doing so will speed up the compilation because it doesn't need to lookup the memory location.</p>
<h2 id="functions"><b>Functions</b>
</h2>
<p>Function definitions have this syntax:</p>
<pre><code class="language-clike line-numbers">ReturnType functionName(ArgumentType1 arg1, ArgumentType2 arg2)
{
   // body
}</code></pre>
<p>Functions can be overloaded: despite having the same name, their argument amount and types can vary. However they can't differ only in the return type.</p>
<h2 id="types"><b>Types</b>
</h2>
<p>Unlike HiseScript, <b>SNEX</b>
 is strictly typed. <b>However there is a very limited set of available types</b>
:</p>
<ul><li><code>int</code>
 - Integer numbers</li>
<li><code>float</code>
 - single precision floating point numbers, marked with a trailing <code>f</code>
: <code>2.012f</code>
</li>
<li><code>double</code>
- double precision floating point numbers</li>
<li><code>bool</code>
 - boolean values (just as intermediate type for expression results)</li>
<li><code>block</code>
 - a wrapper around a preallocated buffer of float numbers</li>
<li><code>event</code>
 - the HiseEvent</li>
</ul>
<p><b>There is no String type</b>
. Conversion between the types is done via a C-style cast:</p>
<pre><code class="language-clike line-numbers">// converts a float to an int
int x = (int)2.0f;</code></pre>
<p>Type mismatches will be implicitely corrected by the compiler if possible (but it will produce a warning message so it's not recommended behaviour to just don't care about types).</p>
<h2 id="variable-visibility"><b>Variable visibility</b>
</h2>
<p><b>SNEX</b>
 variables are visible inside their scope (= <code>{...}</code>
 block) or parent scopes. The inner scope has the highest priority and override variable names is possible:</p>
<pre><code class="language-clike line-numbers">void test()
{
    float x = 25.0f;
    
    {
        float x = 90.0f;
        Console.print(x); // 90.0f;
    }
    
    Console.print(x); // 25.0f;
}</code></pre>
<p>However, since this is a common pitfall for bugs, it will produce a compiler warning.</p>
<h2 id="operators"><b>Operators</b>
</h2>
<h3 id="binary-operations"><b>Binary Operations</b>
</h3>
<p>The usual binary operators are available: </p>
<pre><code class="language-clike line-numbers">a + b; // Add
a - b; // Subtract
a * b; // Multiply
a / b; // Divide
a % b; // Modulo

a++; // post-increment (no pre increment support!)

!a; // Logical inversion
a == b; // equality
a != b; // inequality
a > b; // greater than
a >= b; // greater or equal
// ...</code></pre>
<p>The rules of operator precedence are similar to every other programming language on the planet. You can use parenthesis to change the order of execution:</p>
<pre><code class="language-clike line-numbers">(a + b) * c; // = a * c + b * c</code></pre>
<p>Logical operators are short-circuited, which means that the second branch of a <code>&&</code>
 operator will not be evaluated if the first branch is false:</p>
<pre><code class="language-clike line-numbers">int f1()
{
    Console.print(52.0f);
    return 0;
}

int f2()
{
    Console.print(12.0f);
    return 0;
}

void test()
{
    int c = f1() && f2() ? 2 : 1;
    Console.print(c);
}

// Will print 52 and 1 (f2 will not be executed)</code></pre>
<h3 id="assignment"><b>Assignment</b>
</h3>
<p>Assigning a value to a variable is done via the <code>=</code>
 operator. Other assignment types are supported:</p>
<pre><code class="language-clike line-numbers">int x = 12;
x += 3; // x == 15
x /= 3 // x == 5</code></pre>
<p>You can access elements of a <code>block</code>
 via the <code>[]</code>
 operator:</p>
<pre><code class="language-clike line-numbers">block b;
b[12] = 12.0f;</code></pre>
<p><b>There is an out-of-bounds check that prevents read access violations</b>
 if you use an invalid array index. This comes with some performance overhead, which can be deactivated using a compiler flag.</p>
<h3 id="ternary-operator"><b>Ternary Operator</b>
</h3>
<p>Simple branching inside an expression can be done via the ternary operator:</p>
<pre><code class="language-clike line-numbers">a ? b : c</code></pre>
<p>The false branch will not be evaluated.</p>
<h3 id="function-calls"><b>Function calls</b>
</h3>
<p>You can call other functions using this syntax: <code>functionCall(parameter1, parameter2);</code>
Be aware that forward declaring is not supported so you can't call functions before defining them:</p>
<pre><code class="language-clike line-numbers">void f1()
{
    f2(); // won't work
}

void f1()
{
    doSomething();
}

void f3()
{
    f1(); // now you can call it
}</code></pre>
<h3 id="if-/-else-if-branching"><b>if / else-if branching</b>
</h3>
<p>Conditional execution of entire code blocks is possible using the <code>if</code>
 / <code>else</code>
 keywords:</p>
<pre><code class="language-clike line-numbers">if(condition)
{
    // first case
}
else if (otherCondition)
{
    // second case
    return;
}
else
{
    // fallback code
}

// Some other code (will not be executed if otherCondition was true)</code></pre>
<h3 id="return-statement"><b>Return statement</b>
</h3>
<p>Functions that have a return type need a return statement at the end of their function body:</p>
<pre><code class="language-clike line-numbers">void f1()
{
    // Do something
    return; // this is optional
}

int f2()
{
    return 42; // must return a int
}</code></pre>
<h3 id="block-iterator"><b>Block Iterator</b>
</h3>
<p>The only loop construct in <b>SNEX</b>
 is an iterator for a <code>block</code>
 using the range-based <code>for</code>
 loop syntax of C++:</p>
<pre><code class="language-clike line-numbers">double uptime = 0.0;

for(auto& sample: block)
{
    sample = (float)Math.sin(uptime);
    uptime += 0.002;
}</code></pre>
<p>If you don't know C++, don't bother about the <code>&</code>
 symbol (it just means that it takes a reference to the value so you can actually change it). Be aware that the non-reference version:</p>
<pre><code class="language-clike line-numbers">for(auto sample: block)
    sample = 2.0f;</code></pre>
<p>will not compile, since it would have no effect.</p>
<h3 id="api-classes"><b>API classes</b>
</h3>
<p>There are a few inbuilt API classes that offer additional helper functions.</p>
<ul><li>the <code>Math</code>
 class which contains a set of mathematical functions</li>
<li>the <code>Console</code>
 class for printing a value to the console</li>
<li>the <code>Message</code>
 class which contains methods to operate on a HiseEvent.</li>
</ul>
<p>The syntax for calling the API functions is the same as in HiseScript: <code>Api.function()</code>
.</p>
<pre><code class="language-clike line-numbers">float x = Math.sin(2.0f);</code></pre>
<p class="comment">The <code>Math</code>
 class contains overloaded functions for <code>double</code>
 and <code>float</code>
, so be aware of implicit casts here.</p>
<h2 id="embedding-the-language"><b>Embedding the language</b>
</h2>
<p>Embedding the language in a C++ project is pretty simple:</p>
<pre><code class="language-clike line-numbers">// Create a global scope that contains global variables.
snex::jit::GlobalScope pool;

// Create a compiler that turns a String into a function pointer.
snex::jit::Compiler compiler(pool);

// The SNEX code to be parsed - Check the language reference below
juce::String code = "float member = 8.0f; float square(float input){ member = input; return input * input; }";

// Compiles and returns a object that contains the function code and slots for class variables.
if (auto obj = compiler.compileJitObject(code))
{
    // Returns a wrapper around the function with the given name
    auto f = obj["square"];
    
    // Returns a reference to the variable slot `member`
    auto ptr = obj.getVariablePtr("member");

    DBG(ptr->toFloat()); // 8.0f

    // call the function - the return type has to be passed in via template.
    // It checks that the function signature matches 
    // and the JIT function was compiled correctly.
    auto returnValue = f.call<float>(12.0f);
    
    DBG(returnValue); // 144.0f
    DBG(ptr->toFloat()); // 12.0f
}
else
{
    DBG(compiler.getErrorMessage());
}</code></pre>
<h2 id="examples"><b>Examples</b>
</h2>
<p>These examples show some basic DSP algorithms and how they are implemented in SNEX. In order to use it, just load the given HISE Snippets into the latest version of HISE and play around.</p>
<h3 id="basic-sine-synthesiser"><b>Basic Sine Synthesiser</b>
</h3>
<p>HISE automatically supports polyphony when </p>
<pre><code class="language-clike line-numbers">// we initialise it to a weird value, will get corrected later
double sr = 0.0;

// the counter for the signal generation
double uptime = 0.0;

// the increment value (will control the frequency)
double delta = 0.0;



void prepare(double sampleRate, int blockSize, int numChannels)
{
    // set the samplerate for the frequency calculation
    sr = sampleRate;
}

void reset()
{
    // When we start a new voice, we just need to reset the counter
    uptime = 0.0;
}

void handleEvent(event e)
{
    // get the frequency (in Hz) from the event
    const double cyclesPerSecond = e.getFrequency();

    // calculate the increment per sample
    const double cyclesPerSample = cyclesPerSecond / sr;
    
    // multiyply it with 2*PI to get the increment value
    delta = 2.0 * 3.14159265359 * cyclesPerSample;
}

void processFrame(block frame)
{
    // Calculate the signal
    frame[0] = (float)Math.sin(uptime);

    // Increment the value
    uptime += delta;

    // Copy the signal to the right channel
    frame[1] = frame[0];
}</code></pre>
<pre><code class="language-clike line-numbers">/** Initialise the processing here. */
void prepare(double sampleRate, int blockSize, int numChannels)
{
    x.prepare(sampleRate, 500.0);
}

/** Reset the processing pipeline */
void reset()
{
    x.reset(0.0);
    x.set(1.0);
}

sdouble x = 1.0;

float processSample(float input)
{
    return (float)x.next();
}</code></pre>
<div class="content-footer"><span class="content-footer-left"><a href="https://github.com/christophhart/hise_documentation/edit/master/scriptnode/manual/snex.md">Edit on GitHub</a>
</span>

<span class="content-footer-right">Next: <a href="scriptnode/manual/third_party.html">Third Party C++ Nodes</a>
</span>

<p class="content-footer-metadata">Christoph Hart<br><br></p>
</div>

			<!-- content end -->
		</div>

		<!-- container end -->
	</div>

	 <footer>  
		 <div> <a href="https://github.com/christophhart/hise_documentation/tree/master"> HISE Docs </a> <img src="/template/css/images/pd.svg" width="12px" id="year" style="padding:2px 2px" /></div> 
	 </footer>  

	<script>   document.getElementById("year").innerHTML = new Date().getFullYear();  </script>
	<script src="/template/scripts/prism.js"></script>
	<script src="/template/scripts/autoComplete.js"></script>
	<script src="/template/scripts/search.js"></script>
	
</body>
</html>
